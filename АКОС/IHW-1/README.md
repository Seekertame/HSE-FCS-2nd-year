# Отчет
Исполнитель: Бюрчиев Тимур Зольванович
Группа: БПИ 248

---
### **Вариант 5**

Сформировать массив **B**, состоящий из элементов массива **A**, значение которых **не совпадает с введённым числом X**.

---
### [Ссылка на GitHub](https://github.com/Seekertame/HSE-FCS-2nd-year/tree/main/%D0%90%D0%9A%D0%9E%D0%A1/IHW-1)

___
# Как запускать
- В RARS in Settings (плашка слева сверху) обязательно нужно выбрать: 
  `"Initialize Program Counter to global 'main' if defined"`

- Дальше можно открывать проектные файлы, но важно аккуратно работать с двумя `main`: `main_app.asm` и `main_tests.asm`.

- **Интерактивный режим:** открыть `main_app.asm` → Assemble → Run → ввести `N`, `X`, затем элементы `A[i]` → увидеть `A:` и `B:`.
    
- **Автотесты:** открыть `main_tests.asm` → Assemble → Run → убедиться, что все `CASE k: PASS` и итог `PASSED 6 / 6`.   

---
# Тесты, демонстрирующие корректность 
## Набор кейсов (автотесты `main_tests.asm`)

Мы проверяем как крайние, так и типовые случаи. Во всех тестах строится массив `B = { a ∈ A | a ≠ X }`.

|Case|Входные данные|Ожидаемый результат|Что покрывает|
|---|---|---|---|
|1|`N=1`, `A=[5]`, `X=7`|`B=[5]`, `lenB=1`|Нет совпадений с X|
|2|`N=1`, `A=[7]`, `X=7`|`B=[]`, `lenB=0`|Полное удаление|
|3|`N=10`, `A=[1..10]`, `X=99`|`B=A`, `lenB=10`|Граница по N, отсутствие X|
|4|`N=5`, `A=[3,3,3,3,3]`, `X=3`|`B=[]`, `lenB=0`|Все элементы равны X|
|5|`N=6`, `A=[1,2,3,2,4,2]`, `X=2`|`B=[1,3,4]`, `lenB=3`|Частичное удаление, сохранение порядка|
|6|`N=4`, `A=[-1,0,-1,5]`, `X=-1`|`B=[0,5]`, `lenB=2`|Отрицательные значения|

Тест-раннер:

- Вызывает подпрограмму `filter_ne` (алгоритм) и сверяет: (1) длину `lenB`, (2) контент `B` с эталоном через `memeq`.
    
- Печатает `CASE k: PASS/FAIL` и сводку `PASSED m / 6`.

Дополнительно (необязательные, но полезные) негативные проверки:

- `N<1` или `N>10` в интерактивной версии → повтор ввода (поведение зашито в `read_int_range`).
    
- Пустой результат (`lenB=0`) — уже покрыт кейсами 2 и 4.
    
- Полное сохранение (`lenB=N`) — кейс 3.

---
# Результаты тестовых прогонов

Пример консольного вывода (успешный прогон):

```
CASE 1: PASS
CASE 2: PASS
CASE 3: PASS
CASE 4: PASS
CASE 5: PASS
CASE 6: PASS
PASSED 6 / 6
```

_(Если какой-то тест упадёт, выводится `FAIL`, а в отладочном режиме можно быстро локализовать проблему по номеру кейса.)_

## Примеры ручной проверки (интерактивная версия `main_app`)

- Пример 1:  
    Ввод: `N=6`, `X=2`, `A=1 2 3 2 4 2`  
    Вывод:
    
    ```
    A: 1 2 3 2 4 2 
    B: 1 3 4 
    ```
    
- Пример 2:  
    Ввод: `N=5`, `X=3`, `A=3 3 3 3 3`  
    Вывод:
    
    ```
    A: 3 3 3 3 3 
    B: 
    ```
    
- Пример 3:  
    Ввод: `N=4`, `X=-1`, `A=-1 0 -1 5`  
    Вывод:
    
    ```
    A: -1 0 -1 5 
    B: 0 5 
    ```
    
---
# Дополнительная информация (соответствие критериям)

### Уровень 4–5

- ✅ Ввод с клавиатуры реализован (`read_int`, `read_int_range`, `read_array`); при некорректном `N` — повтор ввода до корректного значения.
    
- ✅ Вывод исходного (`A`) и результирующего (`B`) массивов с поясняющими метками `A:` и `B:`.
    
- ✅ В коде подробные комментарии на английском.
    
- ✅ В отчёте — полное покрытие тестами и пример логов.
    

### Уровень 6–7

- ✅ Параметры всех подпрограмм передаются **через стек** (см. комментарии `Caller pushes …`).
    
- ✅ Локальные переменные во фрейме стека (`s0` как frame pointer, сохранение `ra`, `s0`, выделение кадра).
    
- ✅ Комментарии в местах вызова (в `main_app.asm`/`main_tests.asm`) поясняют, что и где возвращается (`a0 <- N`, `a0 = lenB` и т.д.).
    
- ✅ В отчёте указаны изменения относительно базового уровня: переход на стековые параметры/локальные переменные, модульность.
    

### Уровень 8

- ✅ Подпрограммы универсальны и многократно переиспользуемы: `filter_ne`, `read_*`, `print_array`.
    
- ✅ **Автотесты** вынесены в отдельную программу `main_tests.asm`, никакого ручного ввода, фиксированные кейсы.
    
- ✅ Разбиение на несколько ассемблерных файлов: `alg.asm`, `io.asm`, `macros.asm`, `main_app.asm`, `main_tests.asm`.
    

### Уровень 9

- ✅ Добавлена и используется **библиотека макросов** `macros.asm`:
    
    - Обёртки I/O: `PRINT_STR`, `PRINT_INT`, `PRINT_NL`, `READ_INT`.
        
    - Обёртки вызова подпрограмм через стек: `CALL1/2/3/4`.
        
    - Утилита `INIT_STACK` (устраняет зависимость от настроек RARS).
        
    - Генератор выровненных буферов: `ALLOC_I32_ARRAY10`, `ALLOC_I32_ARRAY_BYTES`.
        
- ✅ Макросы переиспользуются в `main_app.asm` и `main_tests.asm` многократно.
    
- ✅ Макросы выделены в **отдельный автономный файл** и не вшиты в код модулей.

---

# Кратко об архитектуре (добавка к отчёту)

- **Модули:**  
    `alg` — чистый алгоритм `filter_ne(A,N,X,B)→lenB` (без I/O),  
    `io` — унифицированные `read_int(_range)`, `read_array`, `print_array`,  
    `main_app` — интерактивная «склейка»,  
    `main_tests` — автономный тест-раннер,  
    `macros` — библиотека макросов (обёртки I/O, вызовы с параметрами через стек, инициализация стека, выделение буферов).
    
- **Соглашение вызовов:** параметры в стек, результат в `a0`; локальные переменные в кадре стека с сохранением `ra/s0`.
    
- **Надёжность:** явный `INIT_STACK()` в `main`, выравнивание `.align 2` для слов, явный `j main` в тест-раннере (не зависим от настроек RARS).
    
- **Макросы (уровень 9):** `PRINT_*`, `READ_INT`, `CALL1/2/3/4`, `INIT_STACK`, `ALLOC_I32_ARRAY*`.
    
